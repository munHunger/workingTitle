package se.munhunger.workingTitle.util;

import java.awt.Color;
import java.awt.Graphics;
import java.util.function.BiFunction;
import java.util.function.Function;

import javax.swing.JFrame;
import javax.swing.JPanel;

/**
 * A fractal generated by the diamond square algorithm
 * Each value in this fractal will be between 0 and 1
 * 
 * @author munhunger
 * 		
 */
public class DiamondSquareFractal
{
	/**
	 * 2 dimensional array to represent the fractal map
	 */
	private float[][] fractal;
	
	/**
	 * @param args
	 */
	public static void main(String[] args)
	{
		new DiamondSquareFractal();
	}
	
	/**
	 * Builds a DiamondSquareFractal with the specified size
	 * 
	 * @param size
	 *            the size to build. This should be a (2^x)+1 number
	 * @param generateEdges
	 *            true if all edges should be set to 1f. Otherwise the corners
	 *            will be randomly set
	 * @throws IllegalArgumentException
	 *             if the number is not on the format (2^x)+1
	 * 			
	 */
	public DiamondSquareFractal(int size, boolean generateEdges) throws IllegalArgumentException
	{
		if (((size - 1) & (size - 2)) != 0)
			throw new IllegalArgumentException("Must be a number following the format (2^x)+1");
			
		fractal = new float[size][size];
		if (generateEdges)
			initEdges();
		else
			initCorners();
		generate(fractal.length - 1, 0.75f, 0.6f);
	}
	
	/**
	 * Builds a DiamondSquareFractal with a starting size and creates a
	 * JFrame viewing it
	 */
	public DiamondSquareFractal()
	{
		int size = 17;
		fractal = new float[size][size];
		JFrame frame = new JFrame();
		frame.add(new JPanel()
		{
			/**
			 * 
			 */
			private static final long serialVersionUID = 1L;
			
			@Override
			public void paintComponent(Graphics g)
			{
				super.paintComponent(g);
				super.setBackground(Color.PINK);
				int blockSize = 600 / size;
				for (int x = 0; x < fractal.length; x++)
				{
					for (int y = 0; y < fractal.length; y++)
					{
						g.setColor(new Color(fractal[x][y], fractal[x][y], fractal[x][y]));
						if (fractal[x][y] < 0.7f)
							g.setColor(Color.GREEN);
						g.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
						g.setColor(new Color(0f, 0.2f, 0f));
						// g.drawRect(x * size, y * size, size, size);
					}
				}
				try
				{
					Thread.sleep(100);
				}
				catch (InterruptedException e)
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				repaint();
			}
		});
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(600, 625);
		frame.setVisible(true);
		new Thread((Runnable) () ->
		{
			while (true)
			{
				for (int x = 0; x < fractal.length; x++)
					for (int y = 0; y < fractal[x].length; y++)
						fractal[x][y] = 0f;
				initCorners();
				initEdges();
				generate(fractal.length - 1, 1.0f, 0.6f);
				try
				{
					Thread.sleep(1000);
				}
				catch (Exception e)
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}).start();
	}
	
	@Override
	public String toString()
	{
		StringBuilder builder = new StringBuilder();
		for (int x = 0; x < fractal.length; x++)
		{
			for (int y = 0; y < fractal.length; y++)
			{
				builder.append(getValue(x, y) + "  ");
			}
			builder.append("\n\n");
		}
		return builder.toString();
	}
	
	/**
	 * Applies the function on each value in the fractal.
	 * Note that the values will still be cut to be between 0 and 1
	 * 
	 * @param function
	 *            the function to apply. Takes the original value and return the
	 *            new value of the fractal
	 */
	public void apply(Function<Float, Float> function)
	{
		for (int x = 0; x < fractal.length; x++)
			for (int y = 0; y < fractal[x].length; y++)
				fractal[x][y] = Math.min(1f, Math.max(0f, function.apply(fractal[x][y])));
	}
	
	/**
	 * Adds a value to all places in the fractal.
	 * Note that some cutoff might occur as the values in the fractal must range
	 * from 0 to 1
	 * 
	 * @param amount
	 *            the amount to add
	 */
	public void add(float amount)
	{
		for (int x = 0; x < fractal.length; x++)
			for (int y = 0; y < fractal[x].length; y++)
				fractal[x][y] = Math.min(1f, Math.max(0f, fractal[x][y] + amount));
	}
	
	/**
	 * Generates the corners of the map
	 */
	private void initCorners()
	{
		fractal[0][0] = Globals.random.nextFloat();
		fractal[fractal.length - 1][0] = Globals.random.nextFloat();
		fractal[0][fractal[0].length - 1] = Globals.random.nextFloat();
		fractal[fractal.length - 1][fractal[0].length - 1] = Globals.random.nextFloat();
	}
	
	/**
	 * sets all edges to 1f
	 */
	private void initEdges()
	{
		for (int x = 0; x < fractal.length; x++)
			for (int y = 0; y < fractal[x].length; y++)
				if (x == 0 || y == 0 || x == fractal.length - 1 || y == fractal.length - 1)
					fractal[x][y] = 1f;
	}
	
	/**
	 * TODO edit this
	 * 
	 * @param size
	 * @param scale
	 * @param rate
	 */
	private void generate(int size, float scale, float rate)
	{
		Function<Float, Float> addRandom = (avg) ->
		{
			return Math.max(0f, Math.min(1f, avg + (((Globals.random.nextFloat() * 2) - 1) * scale)));
		};
		if (size > 1)
			for (int x = 0; x + size < fractal.length; x += size)
				for (int y = 0; y + size < fractal[x].length; y += size)
				{
					float diamondAvg = (fractal[x][y] + fractal[x][y + size] + fractal[x + size][y]
							+ fractal[x + size][y + size]) / 4f;
					fractal[x + size / 2][y + size / 2] = addRandom.apply(diamondAvg);
				}
		BiFunction<Integer, Integer, Boolean> inRange = (xPos, yPos) ->
		{
			return xPos >= 0 && yPos >= 0 && xPos < fractal.length && yPos < fractal[0].length;
		};
		int halfSize = size / 2;
		
		BiFunction<Integer, Integer, Float> squareAvg = (xPos, yPos) ->
		{
			float avg = 0f;
			float count = 0;
			if (inRange.apply(xPos + halfSize, yPos))
			{
				avg += fractal[xPos + halfSize][yPos];
				count++;
			}
			if (inRange.apply(xPos - halfSize, yPos))
			{
				avg += fractal[xPos - halfSize][yPos];
				count++;
			}
			if (inRange.apply(xPos, yPos + halfSize))
			{
				avg += fractal[xPos][yPos + halfSize];
				count++;
			}
			if (inRange.apply(xPos, yPos - halfSize))
			{
				avg += fractal[xPos][yPos - halfSize];
				count++;
			}
			return avg / count;
		};
		for (int x = 0; x + size < fractal.length; x += size)
			for (int y = 0; y + size < fractal[x].length; y += size)
			{
				if (fractal[x + halfSize][y] == 0f)
					fractal[x + halfSize][y] = addRandom.apply(squareAvg.apply(x + halfSize, y));
				if (fractal[x][y + halfSize] == 0f)
					fractal[x][y + halfSize] = addRandom.apply(squareAvg.apply(x, y + halfSize));
				if (fractal[x + size - halfSize][y + size] == 0f)
					fractal[x + size - halfSize][y + size] = addRandom
							.apply(squareAvg.apply(x + size - halfSize, y + size));
				if (fractal[x + size][y + size - halfSize] == 0f)
					fractal[x + size][y + size - halfSize] = addRandom
							.apply(squareAvg.apply(x + size, y + size - halfSize));
			}
		if (size > 1)
		{
			generate(halfSize, scale * rate, rate);
		}
	}
	
	/**
	 * @param x
	 * @param y
	 * @return the value at the specified x/y coordinate
	 */
	public float getValue(int x, int y)
	{
		return fractal[x][y];
	}
	
	/**
	 * @return the height of this fractal map
	 */
	public int getHeight()
	{
		return fractal != null ? (fractal.length > 0 && fractal[0] != null ? fractal[0].length : -1) : -1;
	}
	
	/**
	 * @return the width of this fractal
	 */
	public int getWidth()
	{
		return fractal != null ? fractal.length : -1;
	}
}
